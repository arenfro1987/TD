//-----------------------------------------------------------------------------
//File Typ.cpp contains member functions of class Typ and derived classes
//for the Subset Pascal Compiler
//-----------------------------------------------------------------------------
//Author: Thomas R. Turner
//E-Mail: trturner@ucok.edu
//January, 2009
//-----------------------------------------------------------------------------
//Copyright January, 2009 by Thomas R. Turner.
//Do not reproduce without permission from Thomas R. Turner.
//-----------------------------------------------------------------------------
//C++ include files and namespace std
//-----------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <cmath>
using namespace std;
//-----------------------------------------------------------------------------
//Application include files
//-----------------------------------------------------------------------------
#include "Typ.h"
#include "Sym.h"
#include "List.h"
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Typ::Typ(TypeKind tk,int sz,int al):typekind(tk),size(sz),alignment(al){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Typ::Print(ostream& o,int level,char* title)
{   static string TK[]=
        {"tk_void"
        ,"tk_address"
        ,"tk_boolean"
        ,"tk_character"
        ,"tk_integer"
        ,"tk_real"
        ,"tk_array"
        ,"tk_range"
        ,"tk_enumerated"
        ,"tk_program"
        ,"tk_procedure"
        ,"tk_function"
        ,"tk_standardprocedure"
        ,"tk_standardfunction"
        };
    o << endl;
    for (int a=0;a<level;a++) o << "  ";
    o << title ;
    o << "typekind(" << TK[typekind] 
      << ") size(" << size 
      << ") alignment(" << alignment
      << ")";
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
TypeKind Typ::Typekind(void){return typekind;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsVoidType(void){return typekind==tk_void;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsAddressType(void){return typekind==tk_address;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsBooleanType(void){return typekind==tk_boolean;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsCharacterType(void){return typekind==tk_character;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsIntegerType(void){return typekind==tk_integer;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsRealType(void){return typekind==tk_real;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsArrayType(void){return typekind==tk_array;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsRangeType(void){return typekind==tk_range;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsEnumeratedType(void){return typekind==tk_enumerated;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsProgramType(void){return typekind==tk_program;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsProcedureType(void){return typekind==tk_procedure;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsFunctionType(void){return typekind==tk_function;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsStandardProcedureType(void){return typekind==tk_standardprocedure;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
bool Typ::IsStandardFunctionType(void){return typekind==tk_standardfunction;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
string Typ::TypeChar(void)
{   static string TC[]=
    {"v","a","b","c","i","r","x"
    ,"i","i","x","x","x","x","x"
    };
    return TC[typekind];
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int Typ::Elements(void){return (int)pow((double)2,(double)size);}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int Typ::Size(void){return size;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Typ::SetSize(int sz){size=sz;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int Typ::Alignment(void){return alignment;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Typ::SetAlignment(int al){alignment=al;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Void::Void(void):Typ(tk_void,0,0){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Address::Address(int sz,int al):Typ(tk_address,sz,al){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Boolean::Boolean(int sz,int al):Typ(tk_boolean,sz,al){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Character::Character(int sz,int al):Typ(tk_character,sz,al){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Integer::Integer(int sz,int al):Typ(tk_integer,sz,al){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Real::Real(int sz,int al):Typ(tk_real,sz,al){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Array::Array(Typ* i,Typ* e)
  :Typ(tk_array,1,1),ityp(i),etyp(e)
{   int c=((Range*)i)->Count();
    int s=e->Size();
    SetSize(c*s);
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Array::Print(ostream& o,int level,char* title)
{   Typ::Print(o,level,title);
    if (ityp) ityp->Print(o,level+1,"index type:");
    if (etyp) etyp->Print(o,level+1,"element type:");
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Typ* Array::IndexType(void){return ityp;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Typ* Array::ElementType(void){return etyp;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int  Array::Stride(void){return etyp->Size();}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Range::Range(ConstantSymbol* l,ConstantSymbol* h)
    :Typ(tk_range,1,1),lo(l),hi(h){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Range::Print(ostream& o,int level,char* title)
{   Typ::Print(o,level,title);
    if (lo) lo->Print(o,level+1,"lo bound:");
    if (hi) hi->Print(o,level+1,"hi bound:");
} 
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
string Range::LoBound(void){return lo->StringValue();}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
string Range::HiBound(void){return hi->StringValue();}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int Range::Count(void)
{   int l=lo->IntegerValue();
    int h=hi->IntegerValue();
    return (h-l+1);
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Enumerated::Enumerated(List<string>& SL,int ll):Typ(tk_enumerated,1,1)
{   L=new List<ConstantSymbol*>;
    Typ* I1=new Integer(1,1);
    int  iv=0;
    for (SL.First();!SL.IsEol();SL.Next()) {
        char cv[20];
        sprintf(cv,"%d",iv);
        string value(cv);
        string id=SL.Member();
        ConstantSymbol* C=new ConstantSymbol(id,I1,value,ll);
        L->Insert(C);
        iv++;
    }
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Enumerated::Enumerated(List<string>& SL,int sz,int al,int ll)
  :Typ(tk_enumerated,sz,al)
{   L=new List<ConstantSymbol*>;
    Typ* I=new Integer(sz,al);
    int  iv=0;
    for (SL.First();!SL.IsEol();SL.Next()) {
        char cv[20];
        sprintf(cv,"%d",iv);
        string value(cv);
        string id=SL.Member();
        ConstantSymbol* C=new ConstantSymbol(id,I,value,ll);
        L->Insert(C);
        iv++;
    }
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Enumerated::Print(ostream& o,int level,char* title)
{   Typ::Print(o,level,title);
    for (L->First();!L->IsEol();L->Next()) {
        ConstantSymbol* C=L->Member();
        if (C) C->Print(o,level+1,"enumeration constant:");
    }
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int Enumerated::Elements(void){return L->Count();}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Function::Function(TypeKind tk):rt(0),P(0),Typ(tk,0,0){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Function::StoreParameters(List<Sym*>* L){P=L;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int Function::ParameterCount(void){return P->Count();}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Function::StoreReturnType(Typ* t){rt=t;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
Typ* Function::ReturnType(void){return rt;}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void Function::Print(ostream& o,int level,char* title)
{   Typ::Print(o,level,title);
    if (rt) rt->Print(o,level+1,"return type:");
    if (P) {
        for (P->First();!P->IsEol();P->Next()) {
            Sym* S=P->Member();
            if (S) S->Print(o,level+1,"parameter:");
        }
    }
}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
StandardFunction::StandardFunction(TypeKind typekind):Typ(typekind,0,0){}
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
void StandardFunction::Print(ostream& o,int level, char* title)
{   Typ::Print(o,level,title);
}
